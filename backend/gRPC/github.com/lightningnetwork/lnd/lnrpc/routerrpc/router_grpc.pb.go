// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: router.proto

package routerrpc

import (
	context "context"
	lnrpc "github.com/Lmare/lightning-test/backend/gRPC/github.com/lightningnetwork/lnd/lnrpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Router_SendPaymentV2_FullMethodName           = "/routerrpc.Router/SendPaymentV2"
	Router_TrackPaymentV2_FullMethodName          = "/routerrpc.Router/TrackPaymentV2"
	Router_TrackPayments_FullMethodName           = "/routerrpc.Router/TrackPayments"
	Router_EstimateRouteFee_FullMethodName        = "/routerrpc.Router/EstimateRouteFee"
	Router_SendToRoute_FullMethodName             = "/routerrpc.Router/SendToRoute"
	Router_SendToRouteV2_FullMethodName           = "/routerrpc.Router/SendToRouteV2"
	Router_ResetMissionControl_FullMethodName     = "/routerrpc.Router/ResetMissionControl"
	Router_QueryMissionControl_FullMethodName     = "/routerrpc.Router/QueryMissionControl"
	Router_XImportMissionControl_FullMethodName   = "/routerrpc.Router/XImportMissionControl"
	Router_GetMissionControlConfig_FullMethodName = "/routerrpc.Router/GetMissionControlConfig"
	Router_SetMissionControlConfig_FullMethodName = "/routerrpc.Router/SetMissionControlConfig"
	Router_QueryProbability_FullMethodName        = "/routerrpc.Router/QueryProbability"
	Router_BuildRoute_FullMethodName              = "/routerrpc.Router/BuildRoute"
	Router_SubscribeHtlcEvents_FullMethodName     = "/routerrpc.Router/SubscribeHtlcEvents"
	Router_SendPayment_FullMethodName             = "/routerrpc.Router/SendPayment"
	Router_TrackPayment_FullMethodName            = "/routerrpc.Router/TrackPayment"
	Router_HtlcInterceptor_FullMethodName         = "/routerrpc.Router/HtlcInterceptor"
	Router_UpdateChanStatus_FullMethodName        = "/routerrpc.Router/UpdateChanStatus"
	Router_XAddLocalChanAliases_FullMethodName    = "/routerrpc.Router/XAddLocalChanAliases"
	Router_XDeleteLocalChanAliases_FullMethodName = "/routerrpc.Router/XDeleteLocalChanAliases"
)

// RouterClient is the client API for Router service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Router is a service that offers advanced interaction with the router
// subsystem of the daemon.
type RouterClient interface {
	// SendPaymentV2 attempts to route a payment described by the passed
	// PaymentRequest to the final destination. The call returns a stream of
	// payment updates. When using this RPC, make sure to set a fee limit, as the
	// default routing fee limit is 0 sats. Without a non-zero fee limit only
	// routes without fees will be attempted which often fails with
	// FAILURE_REASON_NO_ROUTE.
	SendPaymentV2(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[lnrpc.Payment], error)
	// lncli: `trackpayment`
	// TrackPaymentV2 returns an update stream for the payment identified by the
	// payment hash.
	TrackPaymentV2(ctx context.Context, in *TrackPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[lnrpc.Payment], error)
	// TrackPayments returns an update stream for every payment that is not in a
	// terminal state. Note that if payments are in-flight while starting a new
	// subscription, the start of the payment stream could produce out-of-order
	// and/or duplicate events. In order to get updates for every in-flight
	// payment attempt make sure to subscribe to this method before initiating any
	// payments.
	TrackPayments(ctx context.Context, in *TrackPaymentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[lnrpc.Payment], error)
	// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
	// may cost to send an HTLC to the target end destination.
	EstimateRouteFee(ctx context.Context, in *RouteFeeRequest, opts ...grpc.CallOption) (*RouteFeeResponse, error)
	// Deprecated: Do not use.
	//
	// Deprecated, use SendToRouteV2. SendToRoute attempts to make a payment via
	// the specified route. This method differs from SendPayment in that it
	// allows users to specify a full route manually. This can be used for
	// things like rebalancing, and atomic swaps. It differs from the newer
	// SendToRouteV2 in that it doesn't return the full HTLC information.
	SendToRoute(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendToRouteResponse, error)
	// SendToRouteV2 attempts to make a payment via the specified route. This
	// method differs from SendPayment in that it allows users to specify a full
	// route manually. This can be used for things like rebalancing, and atomic
	// swaps.
	SendToRouteV2(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*lnrpc.HTLCAttempt, error)
	// lncli: `resetmc`
	// ResetMissionControl clears all mission control state and starts with a clean
	// slate.
	ResetMissionControl(ctx context.Context, in *ResetMissionControlRequest, opts ...grpc.CallOption) (*ResetMissionControlResponse, error)
	// lncli: `querymc`
	// QueryMissionControl exposes the internal mission control state to callers.
	// It is a development feature.
	QueryMissionControl(ctx context.Context, in *QueryMissionControlRequest, opts ...grpc.CallOption) (*QueryMissionControlResponse, error)
	// lncli: `importmc`
	// XImportMissionControl is an experimental API that imports the state provided
	// to the internal mission control's state, using all results which are more
	// recent than our existing values. These values will only be imported
	// in-memory, and will not be persisted across restarts.
	XImportMissionControl(ctx context.Context, in *XImportMissionControlRequest, opts ...grpc.CallOption) (*XImportMissionControlResponse, error)
	// lncli: `getmccfg`
	// GetMissionControlConfig returns mission control's current config.
	GetMissionControlConfig(ctx context.Context, in *GetMissionControlConfigRequest, opts ...grpc.CallOption) (*GetMissionControlConfigResponse, error)
	// lncli: `setmccfg`
	// SetMissionControlConfig will set mission control's config, if the config
	// provided is valid.
	SetMissionControlConfig(ctx context.Context, in *SetMissionControlConfigRequest, opts ...grpc.CallOption) (*SetMissionControlConfigResponse, error)
	// lncli: `queryprob`
	// Deprecated. QueryProbability returns the current success probability
	// estimate for a given node pair and amount. The call returns a zero success
	// probability if no channel is available or if the amount violates min/max
	// HTLC constraints.
	QueryProbability(ctx context.Context, in *QueryProbabilityRequest, opts ...grpc.CallOption) (*QueryProbabilityResponse, error)
	// lncli: `buildroute`
	// BuildRoute builds a fully specified route based on a list of hop public
	// keys. It retrieves the relevant channel policies from the graph in order to
	// calculate the correct fees and time locks.
	// Note that LND will use its default final_cltv_delta if no value is supplied.
	// Make sure to add the correct final_cltv_delta depending on the invoice
	// restriction. Moreover the caller has to make sure to provide the
	// payment_addr if the route is paying an invoice which signaled it.
	BuildRoute(ctx context.Context, in *BuildRouteRequest, opts ...grpc.CallOption) (*BuildRouteResponse, error)
	// SubscribeHtlcEvents creates a uni-directional stream from the server to
	// the client which delivers a stream of htlc events.
	SubscribeHtlcEvents(ctx context.Context, in *SubscribeHtlcEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HtlcEvent], error)
	// Deprecated: Do not use.
	//
	// Deprecated, use SendPaymentV2. SendPayment attempts to route a payment
	// described by the passed PaymentRequest to the final destination. The call
	// returns a stream of payment status updates.
	SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PaymentStatus], error)
	// Deprecated: Do not use.
	//
	// Deprecated, use TrackPaymentV2. TrackPayment returns an update stream for
	// the payment identified by the payment hash.
	TrackPayment(ctx context.Context, in *TrackPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PaymentStatus], error)
	// *
	// HtlcInterceptor dispatches a bi-directional streaming RPC in which
	// Forwarded HTLC requests are sent to the client and the client responds with
	// a boolean that tells LND if this htlc should be intercepted.
	// In case of interception, the htlc can be either settled, cancelled or
	// resumed later by using the ResolveHoldForward endpoint.
	HtlcInterceptor(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest], error)
	// lncli: `updatechanstatus`
	// UpdateChanStatus attempts to manually set the state of a channel
	// (enabled, disabled, or auto). A manual "disable" request will cause the
	// channel to stay disabled until a subsequent manual request of either
	// "enable" or "auto".
	UpdateChanStatus(ctx context.Context, in *UpdateChanStatusRequest, opts ...grpc.CallOption) (*UpdateChanStatusResponse, error)
	// XAddLocalChanAliases is an experimental API that creates a set of new
	// channel SCID alias mappings. The final total set of aliases in the manager
	// after the add operation is returned. This is only a locally stored alias,
	// and will not be communicated to the channel peer via any message. Therefore,
	// routing over such an alias will only work if the peer also calls this same
	// RPC on their end. If an alias already exists, an error is returned
	XAddLocalChanAliases(ctx context.Context, in *AddAliasesRequest, opts ...grpc.CallOption) (*AddAliasesResponse, error)
	// XDeleteLocalChanAliases is an experimental API that deletes a set of alias
	// mappings. The final total set of aliases in the manager after the delete
	// operation is returned. The deletion will not be communicated to the channel
	// peer via any message.
	XDeleteLocalChanAliases(ctx context.Context, in *DeleteAliasesRequest, opts ...grpc.CallOption) (*DeleteAliasesResponse, error)
}

type routerClient struct {
	cc grpc.ClientConnInterface
}

func NewRouterClient(cc grpc.ClientConnInterface) RouterClient {
	return &routerClient{cc}
}

func (c *routerClient) SendPaymentV2(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[lnrpc.Payment], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[0], Router_SendPaymentV2_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SendPaymentRequest, lnrpc.Payment]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_SendPaymentV2Client = grpc.ServerStreamingClient[lnrpc.Payment]

func (c *routerClient) TrackPaymentV2(ctx context.Context, in *TrackPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[lnrpc.Payment], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[1], Router_TrackPaymentV2_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TrackPaymentRequest, lnrpc.Payment]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_TrackPaymentV2Client = grpc.ServerStreamingClient[lnrpc.Payment]

func (c *routerClient) TrackPayments(ctx context.Context, in *TrackPaymentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[lnrpc.Payment], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[2], Router_TrackPayments_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TrackPaymentsRequest, lnrpc.Payment]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_TrackPaymentsClient = grpc.ServerStreamingClient[lnrpc.Payment]

func (c *routerClient) EstimateRouteFee(ctx context.Context, in *RouteFeeRequest, opts ...grpc.CallOption) (*RouteFeeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RouteFeeResponse)
	err := c.cc.Invoke(ctx, Router_EstimateRouteFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *routerClient) SendToRoute(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendToRouteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendToRouteResponse)
	err := c.cc.Invoke(ctx, Router_SendToRoute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) SendToRouteV2(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*lnrpc.HTLCAttempt, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(lnrpc.HTLCAttempt)
	err := c.cc.Invoke(ctx, Router_SendToRouteV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) ResetMissionControl(ctx context.Context, in *ResetMissionControlRequest, opts ...grpc.CallOption) (*ResetMissionControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetMissionControlResponse)
	err := c.cc.Invoke(ctx, Router_ResetMissionControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) QueryMissionControl(ctx context.Context, in *QueryMissionControlRequest, opts ...grpc.CallOption) (*QueryMissionControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryMissionControlResponse)
	err := c.cc.Invoke(ctx, Router_QueryMissionControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) XImportMissionControl(ctx context.Context, in *XImportMissionControlRequest, opts ...grpc.CallOption) (*XImportMissionControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XImportMissionControlResponse)
	err := c.cc.Invoke(ctx, Router_XImportMissionControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetMissionControlConfig(ctx context.Context, in *GetMissionControlConfigRequest, opts ...grpc.CallOption) (*GetMissionControlConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMissionControlConfigResponse)
	err := c.cc.Invoke(ctx, Router_GetMissionControlConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) SetMissionControlConfig(ctx context.Context, in *SetMissionControlConfigRequest, opts ...grpc.CallOption) (*SetMissionControlConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMissionControlConfigResponse)
	err := c.cc.Invoke(ctx, Router_SetMissionControlConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) QueryProbability(ctx context.Context, in *QueryProbabilityRequest, opts ...grpc.CallOption) (*QueryProbabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryProbabilityResponse)
	err := c.cc.Invoke(ctx, Router_QueryProbability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) BuildRoute(ctx context.Context, in *BuildRouteRequest, opts ...grpc.CallOption) (*BuildRouteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildRouteResponse)
	err := c.cc.Invoke(ctx, Router_BuildRoute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) SubscribeHtlcEvents(ctx context.Context, in *SubscribeHtlcEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HtlcEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[3], Router_SubscribeHtlcEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeHtlcEventsRequest, HtlcEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_SubscribeHtlcEventsClient = grpc.ServerStreamingClient[HtlcEvent]

// Deprecated: Do not use.
func (c *routerClient) SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PaymentStatus], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[4], Router_SendPayment_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SendPaymentRequest, PaymentStatus]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_SendPaymentClient = grpc.ServerStreamingClient[PaymentStatus]

// Deprecated: Do not use.
func (c *routerClient) TrackPayment(ctx context.Context, in *TrackPaymentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PaymentStatus], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[5], Router_TrackPayment_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TrackPaymentRequest, PaymentStatus]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_TrackPaymentClient = grpc.ServerStreamingClient[PaymentStatus]

func (c *routerClient) HtlcInterceptor(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[6], Router_HtlcInterceptor_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_HtlcInterceptorClient = grpc.BidiStreamingClient[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest]

func (c *routerClient) UpdateChanStatus(ctx context.Context, in *UpdateChanStatusRequest, opts ...grpc.CallOption) (*UpdateChanStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateChanStatusResponse)
	err := c.cc.Invoke(ctx, Router_UpdateChanStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) XAddLocalChanAliases(ctx context.Context, in *AddAliasesRequest, opts ...grpc.CallOption) (*AddAliasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddAliasesResponse)
	err := c.cc.Invoke(ctx, Router_XAddLocalChanAliases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) XDeleteLocalChanAliases(ctx context.Context, in *DeleteAliasesRequest, opts ...grpc.CallOption) (*DeleteAliasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAliasesResponse)
	err := c.cc.Invoke(ctx, Router_XDeleteLocalChanAliases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterServer is the server API for Router service.
// All implementations must embed UnimplementedRouterServer
// for forward compatibility.
//
// Router is a service that offers advanced interaction with the router
// subsystem of the daemon.
type RouterServer interface {
	// SendPaymentV2 attempts to route a payment described by the passed
	// PaymentRequest to the final destination. The call returns a stream of
	// payment updates. When using this RPC, make sure to set a fee limit, as the
	// default routing fee limit is 0 sats. Without a non-zero fee limit only
	// routes without fees will be attempted which often fails with
	// FAILURE_REASON_NO_ROUTE.
	SendPaymentV2(*SendPaymentRequest, grpc.ServerStreamingServer[lnrpc.Payment]) error
	// lncli: `trackpayment`
	// TrackPaymentV2 returns an update stream for the payment identified by the
	// payment hash.
	TrackPaymentV2(*TrackPaymentRequest, grpc.ServerStreamingServer[lnrpc.Payment]) error
	// TrackPayments returns an update stream for every payment that is not in a
	// terminal state. Note that if payments are in-flight while starting a new
	// subscription, the start of the payment stream could produce out-of-order
	// and/or duplicate events. In order to get updates for every in-flight
	// payment attempt make sure to subscribe to this method before initiating any
	// payments.
	TrackPayments(*TrackPaymentsRequest, grpc.ServerStreamingServer[lnrpc.Payment]) error
	// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
	// may cost to send an HTLC to the target end destination.
	EstimateRouteFee(context.Context, *RouteFeeRequest) (*RouteFeeResponse, error)
	// Deprecated: Do not use.
	//
	// Deprecated, use SendToRouteV2. SendToRoute attempts to make a payment via
	// the specified route. This method differs from SendPayment in that it
	// allows users to specify a full route manually. This can be used for
	// things like rebalancing, and atomic swaps. It differs from the newer
	// SendToRouteV2 in that it doesn't return the full HTLC information.
	SendToRoute(context.Context, *SendToRouteRequest) (*SendToRouteResponse, error)
	// SendToRouteV2 attempts to make a payment via the specified route. This
	// method differs from SendPayment in that it allows users to specify a full
	// route manually. This can be used for things like rebalancing, and atomic
	// swaps.
	SendToRouteV2(context.Context, *SendToRouteRequest) (*lnrpc.HTLCAttempt, error)
	// lncli: `resetmc`
	// ResetMissionControl clears all mission control state and starts with a clean
	// slate.
	ResetMissionControl(context.Context, *ResetMissionControlRequest) (*ResetMissionControlResponse, error)
	// lncli: `querymc`
	// QueryMissionControl exposes the internal mission control state to callers.
	// It is a development feature.
	QueryMissionControl(context.Context, *QueryMissionControlRequest) (*QueryMissionControlResponse, error)
	// lncli: `importmc`
	// XImportMissionControl is an experimental API that imports the state provided
	// to the internal mission control's state, using all results which are more
	// recent than our existing values. These values will only be imported
	// in-memory, and will not be persisted across restarts.
	XImportMissionControl(context.Context, *XImportMissionControlRequest) (*XImportMissionControlResponse, error)
	// lncli: `getmccfg`
	// GetMissionControlConfig returns mission control's current config.
	GetMissionControlConfig(context.Context, *GetMissionControlConfigRequest) (*GetMissionControlConfigResponse, error)
	// lncli: `setmccfg`
	// SetMissionControlConfig will set mission control's config, if the config
	// provided is valid.
	SetMissionControlConfig(context.Context, *SetMissionControlConfigRequest) (*SetMissionControlConfigResponse, error)
	// lncli: `queryprob`
	// Deprecated. QueryProbability returns the current success probability
	// estimate for a given node pair and amount. The call returns a zero success
	// probability if no channel is available or if the amount violates min/max
	// HTLC constraints.
	QueryProbability(context.Context, *QueryProbabilityRequest) (*QueryProbabilityResponse, error)
	// lncli: `buildroute`
	// BuildRoute builds a fully specified route based on a list of hop public
	// keys. It retrieves the relevant channel policies from the graph in order to
	// calculate the correct fees and time locks.
	// Note that LND will use its default final_cltv_delta if no value is supplied.
	// Make sure to add the correct final_cltv_delta depending on the invoice
	// restriction. Moreover the caller has to make sure to provide the
	// payment_addr if the route is paying an invoice which signaled it.
	BuildRoute(context.Context, *BuildRouteRequest) (*BuildRouteResponse, error)
	// SubscribeHtlcEvents creates a uni-directional stream from the server to
	// the client which delivers a stream of htlc events.
	SubscribeHtlcEvents(*SubscribeHtlcEventsRequest, grpc.ServerStreamingServer[HtlcEvent]) error
	// Deprecated: Do not use.
	//
	// Deprecated, use SendPaymentV2. SendPayment attempts to route a payment
	// described by the passed PaymentRequest to the final destination. The call
	// returns a stream of payment status updates.
	SendPayment(*SendPaymentRequest, grpc.ServerStreamingServer[PaymentStatus]) error
	// Deprecated: Do not use.
	//
	// Deprecated, use TrackPaymentV2. TrackPayment returns an update stream for
	// the payment identified by the payment hash.
	TrackPayment(*TrackPaymentRequest, grpc.ServerStreamingServer[PaymentStatus]) error
	// *
	// HtlcInterceptor dispatches a bi-directional streaming RPC in which
	// Forwarded HTLC requests are sent to the client and the client responds with
	// a boolean that tells LND if this htlc should be intercepted.
	// In case of interception, the htlc can be either settled, cancelled or
	// resumed later by using the ResolveHoldForward endpoint.
	HtlcInterceptor(grpc.BidiStreamingServer[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest]) error
	// lncli: `updatechanstatus`
	// UpdateChanStatus attempts to manually set the state of a channel
	// (enabled, disabled, or auto). A manual "disable" request will cause the
	// channel to stay disabled until a subsequent manual request of either
	// "enable" or "auto".
	UpdateChanStatus(context.Context, *UpdateChanStatusRequest) (*UpdateChanStatusResponse, error)
	// XAddLocalChanAliases is an experimental API that creates a set of new
	// channel SCID alias mappings. The final total set of aliases in the manager
	// after the add operation is returned. This is only a locally stored alias,
	// and will not be communicated to the channel peer via any message. Therefore,
	// routing over such an alias will only work if the peer also calls this same
	// RPC on their end. If an alias already exists, an error is returned
	XAddLocalChanAliases(context.Context, *AddAliasesRequest) (*AddAliasesResponse, error)
	// XDeleteLocalChanAliases is an experimental API that deletes a set of alias
	// mappings. The final total set of aliases in the manager after the delete
	// operation is returned. The deletion will not be communicated to the channel
	// peer via any message.
	XDeleteLocalChanAliases(context.Context, *DeleteAliasesRequest) (*DeleteAliasesResponse, error)
	mustEmbedUnimplementedRouterServer()
}

// UnimplementedRouterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRouterServer struct{}

func (UnimplementedRouterServer) SendPaymentV2(*SendPaymentRequest, grpc.ServerStreamingServer[lnrpc.Payment]) error {
	return status.Errorf(codes.Unimplemented, "method SendPaymentV2 not implemented")
}
func (UnimplementedRouterServer) TrackPaymentV2(*TrackPaymentRequest, grpc.ServerStreamingServer[lnrpc.Payment]) error {
	return status.Errorf(codes.Unimplemented, "method TrackPaymentV2 not implemented")
}
func (UnimplementedRouterServer) TrackPayments(*TrackPaymentsRequest, grpc.ServerStreamingServer[lnrpc.Payment]) error {
	return status.Errorf(codes.Unimplemented, "method TrackPayments not implemented")
}
func (UnimplementedRouterServer) EstimateRouteFee(context.Context, *RouteFeeRequest) (*RouteFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateRouteFee not implemented")
}
func (UnimplementedRouterServer) SendToRoute(context.Context, *SendToRouteRequest) (*SendToRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendToRoute not implemented")
}
func (UnimplementedRouterServer) SendToRouteV2(context.Context, *SendToRouteRequest) (*lnrpc.HTLCAttempt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendToRouteV2 not implemented")
}
func (UnimplementedRouterServer) ResetMissionControl(context.Context, *ResetMissionControlRequest) (*ResetMissionControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetMissionControl not implemented")
}
func (UnimplementedRouterServer) QueryMissionControl(context.Context, *QueryMissionControlRequest) (*QueryMissionControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMissionControl not implemented")
}
func (UnimplementedRouterServer) XImportMissionControl(context.Context, *XImportMissionControlRequest) (*XImportMissionControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method XImportMissionControl not implemented")
}
func (UnimplementedRouterServer) GetMissionControlConfig(context.Context, *GetMissionControlConfigRequest) (*GetMissionControlConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMissionControlConfig not implemented")
}
func (UnimplementedRouterServer) SetMissionControlConfig(context.Context, *SetMissionControlConfigRequest) (*SetMissionControlConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMissionControlConfig not implemented")
}
func (UnimplementedRouterServer) QueryProbability(context.Context, *QueryProbabilityRequest) (*QueryProbabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryProbability not implemented")
}
func (UnimplementedRouterServer) BuildRoute(context.Context, *BuildRouteRequest) (*BuildRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildRoute not implemented")
}
func (UnimplementedRouterServer) SubscribeHtlcEvents(*SubscribeHtlcEventsRequest, grpc.ServerStreamingServer[HtlcEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeHtlcEvents not implemented")
}
func (UnimplementedRouterServer) SendPayment(*SendPaymentRequest, grpc.ServerStreamingServer[PaymentStatus]) error {
	return status.Errorf(codes.Unimplemented, "method SendPayment not implemented")
}
func (UnimplementedRouterServer) TrackPayment(*TrackPaymentRequest, grpc.ServerStreamingServer[PaymentStatus]) error {
	return status.Errorf(codes.Unimplemented, "method TrackPayment not implemented")
}
func (UnimplementedRouterServer) HtlcInterceptor(grpc.BidiStreamingServer[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest]) error {
	return status.Errorf(codes.Unimplemented, "method HtlcInterceptor not implemented")
}
func (UnimplementedRouterServer) UpdateChanStatus(context.Context, *UpdateChanStatusRequest) (*UpdateChanStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChanStatus not implemented")
}
func (UnimplementedRouterServer) XAddLocalChanAliases(context.Context, *AddAliasesRequest) (*AddAliasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method XAddLocalChanAliases not implemented")
}
func (UnimplementedRouterServer) XDeleteLocalChanAliases(context.Context, *DeleteAliasesRequest) (*DeleteAliasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method XDeleteLocalChanAliases not implemented")
}
func (UnimplementedRouterServer) mustEmbedUnimplementedRouterServer() {}
func (UnimplementedRouterServer) testEmbeddedByValue()                {}

// UnsafeRouterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RouterServer will
// result in compilation errors.
type UnsafeRouterServer interface {
	mustEmbedUnimplementedRouterServer()
}

func RegisterRouterServer(s grpc.ServiceRegistrar, srv RouterServer) {
	// If the following call pancis, it indicates UnimplementedRouterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Router_ServiceDesc, srv)
}

func _Router_SendPaymentV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SendPaymentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).SendPaymentV2(m, &grpc.GenericServerStream[SendPaymentRequest, lnrpc.Payment]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_SendPaymentV2Server = grpc.ServerStreamingServer[lnrpc.Payment]

func _Router_TrackPaymentV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrackPaymentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).TrackPaymentV2(m, &grpc.GenericServerStream[TrackPaymentRequest, lnrpc.Payment]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_TrackPaymentV2Server = grpc.ServerStreamingServer[lnrpc.Payment]

func _Router_TrackPayments_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrackPaymentsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).TrackPayments(m, &grpc.GenericServerStream[TrackPaymentsRequest, lnrpc.Payment]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_TrackPaymentsServer = grpc.ServerStreamingServer[lnrpc.Payment]

func _Router_EstimateRouteFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).EstimateRouteFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_EstimateRouteFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).EstimateRouteFee(ctx, req.(*RouteFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_SendToRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).SendToRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_SendToRoute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).SendToRoute(ctx, req.(*SendToRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_SendToRouteV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).SendToRouteV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_SendToRouteV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).SendToRouteV2(ctx, req.(*SendToRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_ResetMissionControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetMissionControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).ResetMissionControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_ResetMissionControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).ResetMissionControl(ctx, req.(*ResetMissionControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_QueryMissionControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMissionControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).QueryMissionControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_QueryMissionControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).QueryMissionControl(ctx, req.(*QueryMissionControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_XImportMissionControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XImportMissionControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).XImportMissionControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_XImportMissionControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).XImportMissionControl(ctx, req.(*XImportMissionControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetMissionControlConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMissionControlConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetMissionControlConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetMissionControlConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetMissionControlConfig(ctx, req.(*GetMissionControlConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_SetMissionControlConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMissionControlConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).SetMissionControlConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_SetMissionControlConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).SetMissionControlConfig(ctx, req.(*SetMissionControlConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_QueryProbability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProbabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).QueryProbability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_QueryProbability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).QueryProbability(ctx, req.(*QueryProbabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_BuildRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).BuildRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_BuildRoute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).BuildRoute(ctx, req.(*BuildRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_SubscribeHtlcEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeHtlcEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).SubscribeHtlcEvents(m, &grpc.GenericServerStream[SubscribeHtlcEventsRequest, HtlcEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_SubscribeHtlcEventsServer = grpc.ServerStreamingServer[HtlcEvent]

func _Router_SendPayment_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SendPaymentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).SendPayment(m, &grpc.GenericServerStream[SendPaymentRequest, PaymentStatus]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_SendPaymentServer = grpc.ServerStreamingServer[PaymentStatus]

func _Router_TrackPayment_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrackPaymentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).TrackPayment(m, &grpc.GenericServerStream[TrackPaymentRequest, PaymentStatus]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_TrackPaymentServer = grpc.ServerStreamingServer[PaymentStatus]

func _Router_HtlcInterceptor_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).HtlcInterceptor(&grpc.GenericServerStream[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Router_HtlcInterceptorServer = grpc.BidiStreamingServer[ForwardHtlcInterceptResponse, ForwardHtlcInterceptRequest]

func _Router_UpdateChanStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChanStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).UpdateChanStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_UpdateChanStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).UpdateChanStatus(ctx, req.(*UpdateChanStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_XAddLocalChanAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAliasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).XAddLocalChanAliases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_XAddLocalChanAliases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).XAddLocalChanAliases(ctx, req.(*AddAliasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_XDeleteLocalChanAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAliasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).XDeleteLocalChanAliases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_XDeleteLocalChanAliases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).XDeleteLocalChanAliases(ctx, req.(*DeleteAliasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Router_ServiceDesc is the grpc.ServiceDesc for Router service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Router_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "routerrpc.Router",
	HandlerType: (*RouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EstimateRouteFee",
			Handler:    _Router_EstimateRouteFee_Handler,
		},
		{
			MethodName: "SendToRoute",
			Handler:    _Router_SendToRoute_Handler,
		},
		{
			MethodName: "SendToRouteV2",
			Handler:    _Router_SendToRouteV2_Handler,
		},
		{
			MethodName: "ResetMissionControl",
			Handler:    _Router_ResetMissionControl_Handler,
		},
		{
			MethodName: "QueryMissionControl",
			Handler:    _Router_QueryMissionControl_Handler,
		},
		{
			MethodName: "XImportMissionControl",
			Handler:    _Router_XImportMissionControl_Handler,
		},
		{
			MethodName: "GetMissionControlConfig",
			Handler:    _Router_GetMissionControlConfig_Handler,
		},
		{
			MethodName: "SetMissionControlConfig",
			Handler:    _Router_SetMissionControlConfig_Handler,
		},
		{
			MethodName: "QueryProbability",
			Handler:    _Router_QueryProbability_Handler,
		},
		{
			MethodName: "BuildRoute",
			Handler:    _Router_BuildRoute_Handler,
		},
		{
			MethodName: "UpdateChanStatus",
			Handler:    _Router_UpdateChanStatus_Handler,
		},
		{
			MethodName: "XAddLocalChanAliases",
			Handler:    _Router_XAddLocalChanAliases_Handler,
		},
		{
			MethodName: "XDeleteLocalChanAliases",
			Handler:    _Router_XDeleteLocalChanAliases_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendPaymentV2",
			Handler:       _Router_SendPaymentV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TrackPaymentV2",
			Handler:       _Router_TrackPaymentV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TrackPayments",
			Handler:       _Router_TrackPayments_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeHtlcEvents",
			Handler:       _Router_SubscribeHtlcEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendPayment",
			Handler:       _Router_SendPayment_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TrackPayment",
			Handler:       _Router_TrackPayment_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HtlcInterceptor",
			Handler:       _Router_HtlcInterceptor_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "router.proto",
}
